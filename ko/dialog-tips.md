---

copyright:
  years: 2015, 2019
lastupdated: "2019-02-21"

subcollection: assistant

---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:deprecated: .deprecated}
{:important: .important}
{:note: .note}
{:tip: .tip}
{:pre: .pre}
{:codeblock: .codeblock}
{:screen: .screen}
{:javascript: .ph data-hd-programlang='javascript'}
{:java: .ph data-hd-programlang='java'}
{:python: .ph data-hd-programlang='python'}
{:swift: .ph data-hd-programlang='swift'}
{:gif: data-image-type='gif'}

# 대화 빌드 팁
{: #dialog-tips}

대화를 빌드하는 방법을 알아보고 더 복잡한 단계를 완료하기 위한 몇 가지 팁을 얻을 수 있습니다.
{: shortdesc}

경험이 많은 대화 디자이너가 제공한 이 팁을 검토하십시오.

## 전체적인 대화 계획
{: #dialog-tips-plan}

- 도구에서 단일 대화 노드를 추가하기 전에 빌드할 대화의 디자인을 계획하십시오. 필요한 경우, 종이에 써봅니다.
- 가능하면 실제 증거와 동작으로 구성된 데이터에 기반하여 디자인을 결정합니다. 누군가가 일어날 수 있다고 *생각하는* 상황을 처리하기 위해 노드를 추가하지 마십시오.
- 비즈니스 프로세스를 있는 그대로 복사하지 마십시오. 이는 거의 대화식이 아닙니다.
- 사용자가 이미 프로세스를 사용 중인 경우, 사용자가 프로세스에 접근하는 방법을 검토하십시오. 일반적으로 사용자는 대화식 관점에서 프로세스를 최적화합니다.
- 어시스턴트의 말투, 성격 및 직책을 결정합니다. 작성한 대화에 선택 사항을 꾸준히 반영합니다.
- 어시스턴트를 사람이라고 잘못 표현하지 마십시오. 사용자들이 어시스턴트가 사람이라고 여기는 경우, 사용자들은 어시스턴트를 믿지 않거나 믿지 않을 가능성이 큽니다.
- 모든 것이 대화식이어야 하는 것은 아닙니다. 때로는 웹 양식이 더 효율적입니다.

## 노드 추가
{: #dialog-tips-nodes}

- 노드의 용도를 설명하는 노드 이름을 추가하십시오.

  지금은 노드의 작업을 알지만, 몇 달이 지나면 모를 수도 있습니다. 사용자 자신과 팀원이 설명이 담긴 노드 이름을 추가한 것에 고마워할 것입니다. 노드 이름이 로그에 표시되고 이는 나중에 대화를 디버그할 때 도움이 될 수 있습니다.
- 태스크를 수행하는 데 필요한 정보를 수집하려면 사용자의 정보를 이끌어내기 위해 개별 노드를 여러 개 사용하는 대신, 슬롯이 있는 노드를 사용하십시오. [슬롯을 사용하여 정보 수집](/docs/services/assistant?topic=assistant-dialog-slots)을 참조하십시오.
- 복잡한 프로세스 플로우의 경우, 프로세스 시작 시 제공해야 하는 정보에 대해 사용자에게 알리십시오.
- 서비스가 대화 트리를 통해 이동하는 방법 및 해당 폴더, 분기, 점프 및 다이그레션이 경로에 미치는 영향을 이해하십시오. [대화 플로우](/docs/services/assistant?topic=assistant-dialog-overview#dialog-overview-flow)를 참조하십시오.
- 모든 곳에 점프를 추가하지는 마십시오. 그럴 경우, 대화 플로우의 복잡도가 증가하고 나중에 대화를 디버그하기 어렵습니다.
- 현재 노드와 동일한 분기에서 노드로 점프하려면 *점프* 대신 *사용자 입력 건너뛰기*를 사용하십시오.

  이 옵션을 선택하면 점프하는 하위 노드를 제거하거나 다시 정렬할 때 현재 노드의 설정을 편집할 수 없습니다. [다음에 수행할 작업 정의](/docs/services/assistant?topic=assistant-dialog-overview#dialog-overview-jump-to)를 참조하십시오.
- 노드로부터의 다이그레션(digression)을 사용으로 설정하기 전에, 가장 일반적인 사용자 시나리오를 테스트하십시오. 다이그레션(digression)  대상 노드가 돌아가도록 구성되었는지 확인하십시오. [다이그레션(digression)](/docs/services/assistant?topic=assistant-dialog-runtime#dialog-runtime-digressions)을 참조하십시오.

## 응답 추가
{: #dialog-tips-responses}

- 답변은 짧고 유용하게 하십시오.
- 응답에 사용자 인텐트를 반영하십시오.

  그럴 경우 사용자는 봇이 자신을 이해했다고 여기고, 그렇지 않은 경우에는 오해를 바로 수정할 수 있는 기회를 사용자에게 제공합니다.
- 자주 변경되는 데이터에 따라 응답이 결정되는 경우 응답에 외부 사이트에 대한 링크만 포함하십시오.
- 지나치게 많은 버튼을 사용하지 마십시오. 사용자가 단추 세트에서 사전 정의된 옵션을 선택하도록 권장하는 것은 실제 대화와 같지 않으며 사용자가 실제로 수행할 작업을 배울 수 있는 능력을 감소시키는 것입니다. 사용자들이 자신들의 단어로 요청하도록 할 때 해당 입력을 사용하여 시스템을 훈련하고 더 나은 인텐트를 이끌어낼 수 있습니다.
- 한 노드가 수행할 때 여러 노드를 사용하지 마십시오. 예를 들어, 여러 조건부 응답을 단일 노드에 추가하여 사용자가 제공한 세부사항에 따라 다른 응답을 리턴합니다. [조건부 응답](/docs/services/assistant?topic=assistant-dialog-overview#dialog-overview-multiple)을 참조하십시오.
- 당신의 반응을 조심스럽게 말로 표현하십시오. 응답을 표현하는 방법에 따라 시스템에 반응하는 방법을 변경할 수 있습니다. 한 행의 텍스트를 변경하여 복잡한 프로그램 솔루션을 구현하기 위해 다중 행의 코드를 작성하지 않아도 될 수 있습니다.
- 스킬을 자주 백업하십시오. [스킬 다운로드](/docs/services/assistant?topic=assistant-skill-add#skill-add-download)를 참조하십시오.

## 사용자 입력에서 정보를 캡처하기 위한 팁
{: #dialog-tips-user-input}

사용자 입력에서 찾으려는 정보를 정확하게 캡처하기 위해 대화 노드에서 사용할 구문을 알기 어려울 수 있습니다. 다음은 공통 목표를 처리하는 데 사용할 수 있는 몇 가지 접근 방식입니다.

- **사용자 입력 리턴**: 사용자가 입력한 정확한 텍스트를 캡처하여 응답으로 리턴할 수 있습니다. 응답에서 다음과 같은 SpEL 표현식을 사용하여 사용자가 응답에 다시 지정한 텍스트를 반복하십시오.

  `사용자 표현: <? input.text ?>.`

- **사용자 입력의 단어 수 결정**: input.text 오브젝트에 대해 지원되는 String 메소드를 수행할 수 있습니다. 예를 들어, 다음과 같은 SpEL 표현식을 사용하여 사용자 발화에 얼마나 많은 단어가 있는지 알 수 있습니다.

  `input.text.split(' ').size()`

  사용할 수 있는 메소드를 추가로 보려면 [String에 사용할 수 있는 표현식 언어 메소드](/docs/services/assistant?topic=assistant-dialog-methods#dialog-methods-strings)를 참조하십시오. 

- **여러 인텐트 처리**: 사용자가 두 개의 개별 작업을 완료하고 싶다는 바람을 나타내는 내용을 입력합니다. `저는 계좌를 개설하고 신용카드를 신청하고 싶습니다.` 어떻게 대화가 이 두 가지를 인식하고 처리합니까? 시도해볼 만한 전략을 보려면 Simon O'Doherty 블로그에서 [복합 질문](https://sodoherty.ai/2017/02/06/compound-questions/){: new_window} 항목을 참조하십시오.(Simon은 {{site.data.keyword.conversationshort}} 팀의 개발자입니다.)

- **모호한 인텐트 처리**: 사용자가 입력한 소망이 모호하여 서비스가 잠재적으로 처리할 수 있는 인텐트가 있는 노드를 두 개 이상 발견한 경우입니다. 대화가 수행할 대화 분기를 아는 방법은 무엇입니까? 모호성 해제를 사용하는 경우 옵션이 표시되어 사용자가 적합한 항목을 선택할 수 있습니다. 자세한 내용은 [모호성 해제](/docs/services/assistant?topic=assistant-dialog-runtime#dialog-runtime-disambiguation)를 참조하십시오.

- **입력에서 다중 엔티티 핸들링**: 엔티티 유형의 첫 번째로 발견된 인스턴스의 값만 평가하려는 경우, `@entity:(specific-value)` 형식 대신 `@entity == 'specific-value'` 구문을 사용할 수 있습니다.

  예를 들어, `@appliance == 'air conditioner'`를 사용하면 첫 번째 발견된 `@appliance` 엔티티의 값만 평가합니다. 하지만 `@appliance:(air conditioner)` 사용이 `entity['appliance'].contains('air conditioner')`로 확장되며, 이는 사용자 입력에 하나 이상의 `@appliance` 엔티티 값 'air conditioner'가 발견될 때마다 일치합니다.

## 조건 사용 팁
{: #dialog-tips-condition-usage}

- **특수 문자가 있는 값에 대해 검사**: 엔티티 또는 컨텍스트 변수에 값이 들어 있는지 확인하고 값에 아포스트로피( ')와 같은 특수 문자가 포함되어 있는지 확인하려면 소괄호로 검사할 값을 묶어야 합니다. 예를 들어, 엔티티 또는 컨텍스트 변수에 `O'Reilly`라는 이름이 있는지 확인하려면, 이름을 소괄호로 묶어야 합니다.

  `@person:(O'Reilly)` 및 `$person:(O'Reilly)`

  서비스는 이러한 단축 참조를 전체 SpEL 표현식으로 변환합니다.

  `entities['person']?.contains('O''Reilly')` 및 `context['person'] == 'O''Reilly'`

  SpEL은 두 번째 어포스트로피를 사용하여 이름의 단일 어포스트로피를 이스케이프합니다.
  {: note}

- **다중 값 검사**: 둘 이상의 값을 검사하려는 경우, OR 연산자(`||`)를 사용하여 조건에서 여러 값을 나열하는 조건을 작성할 수 있습니다. 예를 들어, 컨텍스트 변수 `$state`가 메사추세츠, 메인 또는 뉴햄프셔에 대한 약어를 포함하는 경우 true인 조건을 정의하려면 다음 표현식을 사용할 수 있습니다:

  `$state:MA || $state:ME || $state:NH`

- **숫자 값 검사**: 숫자를 비교할 때 먼저 검사하는 엔티티 또는 변수에 값이 있는지 확인하십시오. 엔티티 또는 변수에 숫자 값이 없는 경우, 숫자 비교에서 널값(0)이 있는 것으로 처리됩니다.

  예를 들어, 사용자 입력에 지정한 달러 값이 100 미만인지를 확인하려고 합니다. `@price < 100` 및 `@price` 엔티티가 널인 조건을 사용하는 경우, 가격이 설정되지 않았지만 0이 100보다 작으므로 조건이 `true`인 것으로 평가됩니다. 이와 같은 부정확한 결과를 방지하려면 조건(예: `@price AND @price < 100`)을 사용하십시오. `@price`에 값이 없으면, 이 조건은 올바르게 false를 리턴합니다.

- **특정 인텐트 이름 패턴이 있는 인텐트 검사**: 패턴과 일치하는 인텐트를 찾는 조건을 사용할 수 있습니다. 예를 들어, 'User_'로 시작하는 인텐트 이름으로 발견된 인텐트를 찾으려면 조건에 다음과 같은 구문을 사용할 수 있습니다.

  `intents[0].intent.startsWith("User_")`

  그러나, 그렇게 하면 발견된 모든 인텐트가 고려되며, 심지어 신뢰도가 0.2 미만인 경우에도 고려됩니다. 또한 Watson이 적절하지 않다고 판단한 인텐트가 신뢰도 점수에 기반하여 리턴되지 않는다는 것을 확인하십시오. 이를 수행하려면, 다음과 같이 조건을 변경하십시오.

  `!irrelevant && intents[0].intent.startsWith("User_")`

- **유사 일치가 엔티티 인식에 미치는 영향**: 엔티티를 조건으로 사용하고 유사 일치가 사용되면, 일치 신뢰도가 30%보다 높은 경우(즉, `@entity_name.confidence > .3`)에만 `@entity_name`이 true로 평가됩니다.

## 입력 시 엔티티 패턴 그룹 저장 및 인식 
{: #dialog-tips-get-pattern-groups}

컨텍스트 변수에 패턴 엔티티 값을 저장하려면 엔티티 이름에 .literal을 추가하십시오. 이 구문을 사용하면 지정된 패턴과 일치하는 사용자 입력의 정확한 범위의 텍스트가 변수에 저장됩니다.

| 변수       | 값                  |
|------------|---------------------|
| email      | <? @email.literal ?> |

그룹이 정의된 패턴 엔티티에 단일 그룹의 텍스트를 저장하려면 저장하려는 그룹의 배열 번호를 지정하십시오. 예를 들어, 엔티티 패턴은 @phone_number 엔티티에 대해 다음과 같이 정의되어 있다고 가정합니다. (소괄호는 패턴 그룹을 나타냅니다.)

`\b((958)|(555))-(\d{3})-(\d{4})\b`

사용자 입력에 지정된 전화 번호의 지역 번호만 저장하려면 다음 구문을 사용할 수 있습니다.

| 변수           | 값                            |
|----------------|-------------------------------|
| area_code      | <? @phone_number.groups[1] ?> |

그룹은 그룹 패턴 정의에 사용되는 정규식으로 구분됩니다. 예를 들어, `@phone_number` 엔티티에 정의된 패턴과 일치하는 사용자 입력이 `958-234-3456`이면, 다음과 같은 그룹이 작성됩니다.

| 그룹 번호    | Regex 엔진 값       | 대화 값   | 설명        |
|--------------|---------------------|----------------|-------------|
| groups[0]    | `958-234-3456`      | `958-234-3456` | 첫 번째 그룹은 항상 전체 일치 문자열. |
| groups[1]    | `((958)`l`(555))`   | `958`          | 첫 번째 정의된 그룹에 대한 regex와 일치하는 다음과 같은 문자열: `((958)`l`(555))`. |
| groups[2]    | `(958)`             | `958`          | OR 표현식의 첫 번째 피연산자로 포함된 그룹과 일치하는 문자열: `((958)`l`(555))` |
| groups[3]    | `(555)`             | `null`         | OR 표현식의 두 번째 피연산자로 포함된 그룹과 일치하는 문자열: `((958)`l`(555))` |
| groups[4]    | `(\d{3})`           | `234`          | 그룹에 대해 정의된 정규식과 일치하는 문자열. |
| groups[5]    | `(\d{4})`           | `3456`         | 그룹에 대해 정의된 정규식과 일치하는 문자열. |
{: caption="그룹 세부사항" caption-side="top"}

관심 있는 입력 섹션을 캡처하는데 사용할 그룹 번호를 해독하려면, 한 번에 모든 그룹에 대한 정보를 추출 할 수 있습니다. 그룹화된 모든 패턴 엔티티 일치 배열을 리턴하는 컨텍스트 변수를 작성하려면 다음 구문을 사용하십시오.

| 변수                     | 값                         |
|--------------------------|----------------------------|
| array_of_matched_groups  | <? @phone_number.groups ?> |

"시험 사용" 분할창을 사용하여 테스트 전화번호 값을 입력하십시오. `958-123-2345`의 경우, 이 표현식은 `$array_of_matched_groups`를 `["958-123-2345","958","958",null,"123","2345"]`로 설정합니다.

그런 다음 배열의 각 값을 0부터 시작하여 그룹 번호를 시작할 수 있습니다.

| 배열 요소 값        | 배열 요소 번호       |
|---------------------|----------------------|
| "958-123-2345"      | 0 |
| "958"               | 1 |
| "958"               | 2 |
| 널                  | 3 |
| "123"               | 4 |
| "2345"              | 5 |
{: caption="배열 요소" caption-side="top"}

예를 들어, 결과에서 전화번호의 마지막 4자리를 캡처하려면, 그룹 #5가 필요하다는 것을 알 수 있습니다.

그룹화된 패턴 엔티티를 표시하기 위해 작성된 JSONArray 구조를 리턴하려면 다음 구문을 사용하십시오.

| 변수                 | 값                              |
|----------------------|---------------------------------|
| json_matched_groups  | <? @phone_number.groups_json ?> |

이 표현식은 `$json_matched_groups`를 다음과 같은 JSON 배열로 설정합니다.

```json
[
  {"group": "group_0","location": [0, 12]},
  {"group": "group_1","location": [0, 3]},
  {"group": "group_2","location": [0, 3]},
  {"group": "group_3"},
  {"group": "group_4","location": [4, 7]},
  {"group": "group_5","location": [8, 12]}
]
```
{: codeblock}

`location`은 0부터 시작하는 문자 오프셋을 사용하여 발견된 엔티티 값이 입력 텍스트에서 시작하고 끝나는 위치를 표시하는 엔티티의 속성입니다.
{: note}

두 개의 전화번호가 입력에 제공될 것으로 예상되면 두 개의 전화번호를 확인할 수 있습니다. 예를 들어, 다음 구문을 사용하여 두 번째 번호의 지역 번호를 캡처합니다.

| 변수             | 값                                          |
|------------------|---------------------------------------------|
| second_areacode  | <? entities['phone_number'][1].groups[1] ?> |

입력이 `I want to change my phone number from 958-234-3456 to 555-456-5678`이면, `$second_areacode`는 `555`입니다.

## API 호출 세부사항 보기
{: #dialog-tips-inspect-api}

"시험 사용" 분할창에서 대화를 테스트할 때, 서비스에서 리턴되는 기본 API 호출이 어떤지를 알고 싶을 수 있습니다. 웹 브라우저에서 제공되는 개발자 도구를 사용하여 이를 검사할 수 있습니다.

예를 들어, Chrome에서 개발자 도구를 여십시오. 네트워크 도구를 클릭하십시오. 이름 섹션에 여러 API 호출이 나열됩니다. 테스트 발언과 관련된 메시지 호출을 클릭한 후, 응답 열을 클릭하여 API 응답 본문을 확인하십시오. 신뢰도 점수와 함께 사용자 입력에서 인식된 인텐트와 엔티티를 나열하고 호출 시 컨텍스트 변수 값을 나열합니다. 응답 본문을 구조화된 형식으로 보려면 미리보기 열을 클릭하십시오.

![Chrome 웹 브라우저 개발자 도구를 사용하여 API 호출 세부사항을 보는 방법을 표시합니다.](images/api-browser-dev.png)
